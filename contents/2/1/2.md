#### Enjeux des modes de représentation, approche systémique

Le développement informatique est une affaire de moyens et de faisabilité. Les modes de représentation associés vont donc avoir pour but de cadrer les modalités dans lesquelles s'exprime l'artefact numérique. Ils permettent de rendre compte des interactions possibles et des besoins matériels et structurels qui en découlent. Nous allons nous intéresser à l'UML et aux différents types de diagrammes qu'il permet de produire. Il est important de noter que les diagrammes UMl sont conçus dans l'optique de définir le comportement d'un système lors de sa conception, il ne s'agit pas d'une définition du terrain initial, ni même d'acteurs en situation avant l'application de la solution. Ces diagrammes ne sont pas une aide à la conception mais bien un guide de production normalisé. Le diagramme des cas d'utilisation par exemple, qui définie les interactions entre des acteurs et le système, n'est pas un diagramme d'étude préalable, démontrant les actions existantes à prendre en compte dans la conception, mais une représentation des actions disponibles *in fine* dans l'application. Ces représentations sont des spécifications techniques qui permettent de passer à une phase de développement.

Comme tout descriptif technique et matériel, la justesse de cette représentation et la concordance avec le besoin de l'utilisateur dépend de l'étude préalable qui a permis de dégager les besoins sur le terrain. Néanmoins, on peut faire l'hypothèse qu'à l'imagine des couches d'abstractions, le langage formel UML induit une perte d'informations entre l'expression du besoin recueillie sur le terrain et sa représentation. Aussi, on peut considérer que la réification de l'utilisateur en acteur dans les schémas UML est déjà un arraisonnement de l'utilisateur au système, c'est à dire une considération de l'action de l'utilisateur comme dépendant du système qui lui propose l'action, et non l'inverse. B. Bachimont démontre dans son ouvrage (Bachimont 2010) que le dispositif arraisonne l'utilisateur à son fonctionnement, en faisant un opérateur plus qu'un utilisateur qui dispose d'un outil, un agent uniquement délégué à initier une action dans le système et à en traiter les réponses. Un logiciel n'est pas un outil dans la mesure où l'outil est décontextualisé et peut s'appliquer à différentes situations, à l'image d'un marteau par exemple. M. Baudouin-Lafon et O. Beaudoux dans un article ont d'ailleurs démontrés dans un article (Beaudoux et Beaudouin-Lafon 2001) que les applications et logiciels étaient conçus comme des environnements dans lesquels les actions sont préprogrammées et non transposables à d'autres environnements applicatifs. L'UML est une des étapes de la grammatisation de B. Stiegler vue précédemment : le langage formelle discrétise le réel et le réifie en objets numériques. Étant donné que la contrainte est en définitif une contrainte de production logicielle, on peut se demander dans quelle mesure l'UML n'est pas seulement l'instrument d'une « conformisation » aux contraintes techniques du système, plutôt qu'une extraction du réel contexte du terrain et de ses besoins. Un détail frappant concernant les diagramme des cas d'utilisation est la représentation des utilisateurs-acteurs-opérateurs dans le système. En bon langage formel, un unique pictogramme sert de représentation, la plupart du temps un « bonhomme bâton », associé à son rôle dans le système. Un article de blog de G. Dorne montre les différentes manières de dessiner l'être humain qu'utilisent 14 architectes différents (Dorne 2016). Chacun a une manière bien à lui de le représenter et on peut faire l'hypothèse que chacune, d'une manière réflexive dans le projet, véhicule et concourt à une idéologie globale du projet, en amont et pendant son développement. Dans le cas de l'UML qui est normalisé, on a affaire à une instance quelconque d'un acteur, sans trajectoire et sans contexte, de sorte qu'une fois installé dans le contexte final d'application, le logiciel rencontre souvent ses vraies problématiques. Définir l'utilisateur dans un projet et le représenter pour garder constamment à l'esprit à qui est destiné le logiciel est donc essentiel quel que soit la représentation. Tout processus qui vise à le normaliser nécessite une attention particulière pour ne pas qu'il soit écrasé par le système conçut initialement pour lui.

Une expression que j'ai pu entendre durant mon apprentissage du design, de la part de professeurs, et qui vaut autant en développant et en design est que « l'utilisateur est un idiot », sous-entendu qu'il faut considérer l'utilisateur final comme un idiot et simplifier les choses au maximum en nivelant la complexité des interactions et de l'interface par le bas, de sorte que « n'importe qui » puisse utiliser le logiciel. Pourtant, nous avons et aurons toujours besoin d'assistance technique dans les entreprises. Cela veut-il dire que l'utilisateur est effectivement idiot et qu'il faut pousser encore plus loin la formule ? Le problème malheureusement est souvent toujours le même : l'utilisateur conçu comme assujetti au système n'est pas pris en compte dans sa trajectoire personnelle. Les modèles et affordances qu'il peut calquer sur les interfaces ne sont pas prises en compte et il est considérer comme un idiot au titre des raisonnements qu'il préétablira sur le système et au titre de son ignorance du fonctionnement interne de l'artefact. Autrement dit, généraliser des méthodes à des utilisateurs non ciblés et non contextualisés, c'est utiliser des modèles d'idiots systémiques. L'idiot systémique, en miroir à la notion d'idiot culturel de H. Garfinkel (Garfinkel 1984) est un utilisateur dont les potentiels d'actions sont strictement bornés aux actions rendus disponibles par le programme. L'utilisateur n'est pas un idiot initialement, mais le système le fait devenir idiot. Cette hypothèse peut être appuyer par l'approche systémique de l'école de Palo Alto si l'on considère le logiciel comme un système homéostatique, préservant l'équilibre de leur état initial par des mécanismes de régulation (Picard et Marc 2013). Un utilisateur conçut comme idiot pendant la phase de conception d'un logiciel le restera tant que la définition du système ne change pas. Plus précisément, on pourrait considérer que ce paradigme de conception engage une double contrainte, c'est à dire une situation dans laquelle un individu soit se plier à deux obligations, chacune impliquant une interdiction de l'autre, selon la définition de G. Bateson (Bateson 1995). L'utilisateur final se trouve dans un système qui l'anticipe comme idiot et qui le somme parallèlement de se montrer « intelligent » et autonome dans la compréhension du système. N'étant pas un idiot systémique, l'utilisateur ne peut convenir substantiellement à la première définition, mais n'est pas pour autant en mesure de convenir à la seconde. Cette situation interprétée ainsi apparaît extrêmement pénible à vivre pour l'utilisateur qui quoi qu'il fasse est définit comme la cause des problèmes, qui seront forcément liés à un « mauvais usage ». Il faut toutefois nuancer le propos et signaler qu'au delà des modes de représentations, ce sont aussi les méthodologies de travail qui conditionnent la vision de l'utilisateur au sein du projet.

<!--
double contrainte de l'utilisateur ? Bateson : soit idiot (systémique), mais soit intelligent (usage) ?
-->