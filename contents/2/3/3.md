#### Création des méthodes par l'utilisateur : proposition de dépassement

Les fonctionnalités d'un logiciels sont finies : à l’exécution du programme, les fonctionnalités préprogrammées sont chargée et l'interface nous en donne l'accès. Éventuellement, certains logiciels permettront d'articuler ces fonctionnalités via un système de *script* ou *macro*. La finitude de ce système est l'automatisation de tâche plus ou moins complexe. Les scripts sont même dans certains cas des possibilité d'extension du logiciel, au sens où celui-ci permet parfois de créer des éléments d'interface qui permettent de paramétrer le script et interagir avec.

![](./assets/img/scripts_dialog.jpg)
*Exemple d'une boîte de script dans Adobe After effect*
{: .legende}

L'édition de script est un élément essentiel pour qui veut adapter les fonctionnalité à des contextes précis différents. Étant donné que les logiciels tendent à être des omnilogiciels, c'est à dire convenir à l'édition global d'un type de média dans son ensemble, il est parfois nécessaire de les étendre pour les rendre spécifique à l'édition d'une typologie de documents en particulier. Un document administratif par exemple ne partage pas la même disposition qu'une affiche ou un lettre. Les catégories de documents sont identifiés en fonction de la disposition, dans l'espace documentaire, au sens de Y. Jeanneret, à savoir dans tout l'espace de présentation matériel du document (Jeanneret 2007), des éléments de contenu. Il arrive aussi souvent de créer des modèle de documents qui servent à les identifier en tant que tout cohérent. Dans ces circonstance il peut être intéressant de définir des scripts qui systématisent certaines tâches de présentation. À mon sens, tous les programmes devraient inclurent des scripts car ils sont un moyen pour l'utilisateur de faire convenir le logiciel à son besoin.

Seulement, écrire des scripts dans un langage formel n'est pas forcement à la portée de tout le monde. Pour palier à ce problème, on peut prendre exemple sur Tynker. Cet environnement de développement, plutôt destiné aux enfants, permet de leur apprendre la programmation en manipulant des briques logiques numériques.

![](./assets/img/tynker.png) 
*Un exemple de programmation basique sur Tynker*
{: .legende}

Voici à quoi pourrait ressembler un script dans le cas de notre traitement de texte précédent : `mettre en gras`{: .toolFunction} -> `souligner`{: .toolFunction} -> `augmenter le corps`{: .toolFunction} `de`{: .toolFunction} `3`{: .variable}.

![](./assets/img/context_0.png) 

*Exécution du script.*

![](./assets/img/context_3.png) 

Les briques logiques peuvent quasiment être lues en langage naturelles et permettent d'accéder aux fonctionnalités de l'application pour en tirer partie au mieux. D. Genthner et J. Nielsen déplorent d'ailleurs dans leur article (Gentner & Nielsen, 1996) le manque d'efficacité des interfaces basées sur la « manipulation direct », autrement sur le fait de cliquer sur chacune des fonctions à exécuter l'une après l'autre. Ce que l'article pointe du doigt, c'est d'une part la répétitivité de ce processus et le fait que l'utilisateur ne fait que « déclencher » les fonctions et les paramétrer. En ce sens, il se rapproche d'un opérateur. Aussi, l'article met en lumière que la nature calculatoire du système peut être bien plus précis que l’œil et la main, et être dynamique. Plutôt que de placer des élément au centre d'un dessin à la main, et devoir replacer ce même élément dès lors que la taille de l'image change, l'utilisateur devrait pouvoir renseigner l'ordinateur sur un « comportement » que cet élément doit maintenir, de sorte qu'il délègue à la machine le soin de recalculer sa position.

Les utilisateurs auraient énormément à gagner à pouvoir systématiquement « programmer » les choses pour pouvoir se décharger des tâches de manipulations spatiales de base et les traitements en séries. Mais qu'en pense l'utilisateur en question ? Car il est plutôt évident pour quelqu'un de familier avec l'informatique, qui aura l'habitude de détourner, adapter, programmer ses outils de prôner une solution qu'il maîtrise et dont il connaît la faisabilité et le potentiel. Mais qu'en est-il de l'utilisateur et comment se considère-t-il au sein du système ?


